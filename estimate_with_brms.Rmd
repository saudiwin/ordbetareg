---
title: "How to Run Ordered Beta Regression with `brms`"
author: Robert Kubinec
output: html_notebook
---

```{r setup, include=F}

require(brms)
require(dplyr)
require(ggplot2)

set.seed(71520177)

```


This notebook contains instructions for running the ordered beta regression model in the R package `brms`, a front-end to the Stan Hamiltonian Markov Chain Monte Carlo sampler. The ordered beta regression model is designed explicitly for slider scale/visual analog scale data of the type you will often find in online surveys among other areas. I refer you to a paper on the model if you are not familiar with it: .

The ordered beta regression model is not natively supported in `brms` and so instead I define it here using the [custom response option](https://cran.r-project.org/web/packages/brms/vignettes/brms_customfamilies.html) of `brms`. 

First, we can simulate some data using R. We are interested in capturing the value of the coefficient `X_beta` from the simulation.

```{r}

N <- 1000
  
X <- rnorm(N,0,1)
  
X_beta <- 1.2
eta <- X*X_beta
  
# ancillary parameter of beta distribution
phi <- 3
  
cutpoints <- c(-2,2)
  
# probabilities for three possible categories (0, proportion, 1)
low <- 1-plogis(eta - cutpoints[1])
middle <- plogis(eta-cutpoints[1]) - plogis(eta-cutpoints[2])
high <- plogis(eta - cutpoints[2])
  
# we'll assume the same eta was used to generate outcomes
  
out_beta <- rbeta(N,plogis(eta) * phi, (1 - plogis(eta)) * phi) 
  
# now determine which one we get for each observation
outcomes <- sapply(1:N, function(i) {
  sample(1:3,size=1,prob=c(low[i],middle[i],high[i]))
})
  
# now combine binary (0/1) with proportion (beta)
  
final_out <- sapply(1:length(outcomes),function(i) {
    if(outcomes[i]==1) {
      return(0)
    } else if(outcomes[i]==2) {
      return(out_beta[i])
    } else {
      return(1)
    }
})

```

The vector `final_out` contains both degenerate (0 and 1) and continuous responses between 0 and 1. We can see the distinct U-shape of the distribution in the following histogram:

```{r hist}

hist(final_out)

```


To model this in `brms`, we first use the `custom_family` function as follows:

```{r customfam}

# custom family

ord_beta_reg <- custom_family("ord_beta_reg",
                              dpars=c("mu","phi"),
                              links=c("logit","log"),
                              lb=c(NA,0),
                              type="int",
                              vars="vreal1[n]",
                              threshold="flexible",
                              specials="ordinal")

# stan code for density of the model

stan_funs <- "real ord_beta_reg_lpmf(int y, real mu, real phi, vector threshold,real y_cont) {
    // depends on whether y is degenerate or not
    real mu_logit = logit(mu);
    if(y==1) {
      return log1m_inv_logit(mu_logit - threshold[1]);
    } else if(y==2) {
      return log_inv_logit(mu_logit  - threshold[2]);
    } else {
      return log(inv_logit(mu_logit  - threshold[1]) - inv_logit(mu_logit - threshold[2])) +
                beta_proportion_lpdf(y_cont|mu,phi);
    }
  }
  
  real ord_beta_reg_rng(real mu, real phi, vector threshold) {
    int outcome;
    
    outcome = ordered_logistic_rng(mu,threshold);
    
    if(outcome==1) {
      return 0;
    } else if(outcome==3) {
      return 1;
    } else {
      return beta_proportion_rng(inv_logit(mu),phi);
    }
    
  }"

stanvars <- stanvar(scode=stan_funs,block="functions")

to_brms_data <- tibble(y=final_out,x=X)
to_brms_data$y_orig <- to_brms_data$y
to_brms_data$y_cont <- ifelse(to_brms_data$y<1 & to_brms_data$y>0,to_brms_data$y,0)
to_brms_data$y <- ifelse(to_brms_data$y %in% c(0,1),to_brms_data$y+1,
                                3)
to_brms_data$y <- as.integer(to_brms_data$y)

posterior_predict_ord_beta_reg <- function(i, draws, ...) {
  mu <- draws$dpars$mu[, i]
  phi <- draws$dpars$phi
  threshold <- draws$thres$thres
  ord_beta_reg_rng(mu, phi, threshold)
}

pp_expect_ord_beta_reg <- function(draws) {

  thres <- draws$thres$thres
  mu <- draws$dpars$mu
  
  low <- 1 - plogis(qlogis(mu) - thres[,1])
  middle <- plogis(qlogis(mu)-thres[,1]) - plogis(qlogis(mu) - thres[,2])
  high <- plogis(qlogis(mu) - thres[,2])
  
  #low*0 + middle*mu + high
  cbind(low,middle,high)
}

log_lik_ord_beta_reg <- function(i, draws) {

  mu <- draws$dpars$mu[i]
  phi <- draws$dpars$phi[i]
  y <- as.integer(draws$data$Y[i])
  y_cont <- draws$data$vreal1[i]
  thres <- draws$thres$thres[i,]
  
  if(y==1) {
    log(1 - plogis(qlogis(mu) - thres[1]))
  } else if(y==2) {
    log(plogis(qlogis(mu) - thres[2]))
  } else {
    log(plogis(qlogis(mu)-thres[1]) - plogis(qlogis(mu) - thres[2])) + dbeta(y,mu*phi,(1-mu)*phi,log=T)
  }
  
}

brms_fit <- brm(y | thres(2) + vreal(y_cont)~x, data=to_brms_data,
                family=ord_beta_reg,
                stanvars=stanvars)

```

